import json
import subprocess
from pathlib import Path

import click
import requests


@click.command()
@click.argument("project-name", type=str)
@click.option(
    "--bgcflow-dir",
    type=click.Path(exists=True, file_okay=False, dir_okay=True),
    default=".",
    help="The root directory of the BGCFlow project.",
)
@click.option(
    "--dbt-dir",
    type=click.Path(exists=True, file_okay=False, dir_okay=True),
    default=None,
    help="The directory containing the dbt project to upload. If None, the directory is inferred from the BGCFlow project directory.",
)
@click.option(
    "--metabase-host",
    type=str,
    default="http://localhost:3000",
    help="The URL of the Metabase server.",
)
@click.option(
    "--mb-username",
    type=str,
    default=None,
    help="The Metabase username. If None, the user will be prompted to enter their username.",
)
@click.option(
    "--mb-password",
    type=str,
    default=None,
    help="The Metabase password. If None, the user will be prompted to enter their password.",
    hide_input=True,
)
@click.option(
    "--dbt-schema",
    type=str,
    default="main",
    help="The name of the dbt schema to use.",
)
@click.option(
    "--metabase-database",
    type=str,
    default=None,
    help="The name of the Metabase database to use.",
)
@click.option(
    "--dbt-database",
    type=str,
    default="dbt_bgcflow",
    help="The name of the dbt database to use.",
)
@click.option(
    "--metabase-http",
    is_flag=True,
    help="Use HTTP instead of HTTPS to connect to Metabase.",
)
@click.help_option("--help", "-h")
def upload_and_sync_to_metabase(
    project_name: str,
    bgcflow_dir: str,
    dbt_dir: str,
    metabase_host: str,
    mb_username: str,
    mb_password: str,
    dbt_schema: str = "main",
    dbt_database: str = "dbt_bgcflow",
    metabase_http: bool = True,
    metabase_database: str = None,
) -> str:
    """
    Uploads a DuckDB database file generated by dbt to Metabase and syncs the dbt models.

    Args:
        project_name (str): The name of the project to upload to Metabase.
        bgcflow_dir (str): The root directory of the BGCFlow project.
        dbt_dir (str): The directory containing the dbt project to upload. If None, the directory is inferred from the BGCFlow project directory.
        metabase_host (str): The URL of the Metabase server.
        mb_username (str): The Metabase username. If None, the user will be prompted to enter their username.
        mb_password (str): The Metabase password. If None, the user will be prompted to enter their password.
        dbt_schema (str): The name of the dbt schema to use.
        dbt_database (str): The name of the dbt database to use.
        metabase_http (bool): Whether to use HTTP instead of HTTPS to connect to Metabase.
        metabase_database (str): The name of the Metabase database to use. If None, the project name is used.

    Returns:
        str: The output of the dbt-metabase command as a string.

    Raises:
        AssertionError: If the dbt_dir or bgcflow_dir do not exist or are not directories.
        subprocess.CalledProcessError: If the dbt-metabase command fails.
    """
    if dbt_dir is None:
        report_dir = Path(bgcflow_dir) / f"data/processed/{project_name}"
        with open(report_dir / "metadata/dependency_versions.json", "r") as f:
            dependency_version = json.load(f)
        antismash_version = dependency_version["antismash"]
        dbt_dir = report_dir / f"dbt/antiSMASH_{antismash_version}"

    elif isinstance(dbt_dir, str):
        dbt_dir = Path(dbt_dir)

    # Get Metabase session token
    if mb_username is None:
        mb_username = click.prompt("Enter your Metabase username")
    if mb_password is None:
        mb_password = click.prompt("Enter your Metabase password", hide_input=True)

    response = upload_dbt_to_metabase(
        project_name, bgcflow_dir, dbt_dir, metabase_host, mb_username, mb_password
    )
    if response == 200:
        if metabase_database is None:
            metabase_database = project_name
        sync_dbt_models_to_metabase(
            dbt_dir,
            dbt_database,
            metabase_host,
            mb_username,
            mb_password,
            metabase_database,
            dbt_schema,
            metabase_http,
        )


def upload_dbt_to_metabase(
    project_name: str,
    bgcflow_dir: str,
    dbt_dir: str,
    metabase_host: str,
    mb_username: str,
    mb_password: str,
) -> str:
    """
    Uploads a DuckDB database file generated by dbt to Metabase.

    Args:
        project_name (str): The name of the project to upload to Metabase.
        bgcflow_dir (str): The path to the BGCflow directory.
        dbt_dir (str): The path to the dbt directory containing the DuckDB database file.
        metabase_host (str): The URL of the Metabase server.
        mb_username (str): The username to use for authentication with Metabase.
        mb_password (str): The password to use for authentication with Metabase.

    Returns:
        str: The HTTP status code of the request.

    Raises:
        AssertionError: If the DuckDB database file does not exist or is not a regular file.

    """
    if dbt_dir is None:
        report_dir = Path(bgcflow_dir) / f"data/processed/{project_name}"
        with open(report_dir / "metadata/dependency_versions.json", "r") as f:
            dependency_version = json.load(f)
        antismash_version = dependency_version["antismash"]
        dbt_dir = report_dir / f"dbt/antiSMASH_{antismash_version}"

    elif isinstance(dbt_dir, str):
        dbt_dir = Path(dbt_dir)

    duckdb_path = dbt_dir / "dbt_bgcflow.duckdb"
    assert (
        duckdb_path.is_file()
    ), f"Error: {duckdb_path} does not exist or is not a regular file"

    session_response = requests.post(
        f"{metabase_host}/api/session",
        json={"username": mb_username, "password": mb_password},
    )
    session_token = session_response.json()["id"]

    # Check if database already exists
    database_response = requests.get(
        f"{metabase_host}/api/database", headers={"X-Metabase-Session": session_token}
    )
    databases = database_response.json()
    database_id = None
    for k, v in databases.items():
        if k == "data":
            for db in v:
                if db["name"] == project_name:
                    database_id = db["id"]
                    break

    # Prompt user to continue or cancel upload
    if database_id is not None:
        user_input = input(
            f"WARNING: A database with the name '{project_name}' already exists in Metabase. Do you want to continue with the upload? (y/n) "
        )
        if user_input.lower() != "y":
            click.echo("Database upload cancelled by user")
            return

    # Upload or update database in Metabase
    if database_id is None:
        database_response = requests.post(
            f"{metabase_host}/api/database",
            headers={"X-Metabase-Session": session_token},
            json={
                "engine": "duckdb",
                "name": project_name,
                "details": {"database_file": str(duckdb_path.resolve())},
            },
        )
        if database_response.status_code == 200:
            click.echo(f"Database '{project_name}' uploaded successfully")
        else:
            click.echo(
                f"Error uploading database '{project_name}': {database_response.text}"
            )

    else:
        database_response = requests.put(
            f"{metabase_host}/api/database/{database_id}",
            headers={"X-Metabase-Session": session_token},
            json={
                "engine": "duckdb",
                "name": project_name,
                "details": {"database_file": str(duckdb_path.resolve())},
            },
        )
        if database_response.status_code == 200:
            click.echo(f"Database '{project_name}' updated successfully")
        else:
            click.echo(
                f"Error updating database '{project_name}': {database_response.text}"
            )

    return database_response.status_code


def sync_dbt_models_to_metabase(
    dbt_dir: str,
    dbt_database: str,
    metabase_host: str,
    metabase_user: str,
    metabase_password: str,
    metabase_database: str,
    dbt_schema: str = "main",
    metabase_http: bool = True,
) -> str:
    """
    Synchronizes dbt models to Metabase using the dbt-metabase package.

    Parameters:
    dbt_dir (str): The path to the dbt project directory.
    dbt_database (str): The name of the dbt database to use.
    metabase_host (str): The URL of the Metabase server.
    metabase_user (str): The username of the Metabase account to use.
    metabase_password (str): The password of the Metabase account to use.
    metabase_database (str): The name of the Metabase database to use.
    dbt_schema (str, optional): The name of the dbt schema to use. Defaults to "main".
    metabase_http (bool, optional): Whether to use HTTP instead of HTTPS for the Metabase connection. Defaults to False.

    Returns:
    str: The output of the dbt-metabase command as a string.
    """
    if metabase_http:
        metabase_http = "--metabase_http"
    command = [
        "dbt-metabase",
        "models",
        "--dbt_path",
        dbt_dir,
        "--dbt_database",
        dbt_database,
        "--metabase_host",
        metabase_host.split("://")[-1],
        "--metabase_user",
        metabase_user,
        "--metabase_password",
        metabase_password,
        "--metabase_database",
        metabase_database,
        "--dbt_schema",
        dbt_schema,
        metabase_http,
    ]

    # Run the command and capture the output
    result = subprocess.run(
        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True
    )

    # Print the output
    print(result.stdout)
    print(result.stderr)


if __name__ == "__main__":
    upload_and_sync_to_metabase()
